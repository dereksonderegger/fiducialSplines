{
    "contents" : "#' Predict the value of the function at the given x-values\n#' @param x Vector of x-values\n#' @param spline An object produced by fiducialSpline\nE.spline <- function(x, spline){\n  degree <- length(spline$alpha) - length(spline$knots) - 1\n  X <- tp(x, knots=spline$knots, degree=degree)\n  Ey <- X %*% spline$alpha\n  return(Ey)\n}\n\n\n#' Sample from fiducial b-spline distribution\n#' \n#' @param x Vector of x-values\n#' @param y Vector of y-values\n#' @param degree Degree of the b-spline to fit to the data\n#' @param num.knots A scalar or vector of the number of knot points to be considered. e.g. 3:5 or just 3.\n#' @param sigma.jitter MCMC tuning parameter: the size of jumps for the knot point locations.\n#' @param sigma.split MCMC tuning parameter: how far apart knots end up when we split one.\n#' @param chain.length How long a MCMC to create.\n#' @param start.point A list of starting points \n#' @param burn.in The length of chain to be considered 'burn in'.\n#' @param num.chains How many chains to create.\n#' @param num.jacobians How many randomly selected jacobians to average for each step of the MCMC.\n#' @examples \n#' require(SemiPar)\n#' data(lidar)\n#' x <- lidar$range\n#' y <- lidar$logratio\n#' plot(x, y)\n\n#' foo <- fiducial.spline(x, y, 3, 2)\n#' plot(foo)  # plot the three chains...\n#' confint(foo)\n#' @export\nfiducial.spline <- function(x, y, degree, num.knots, sigma.jitter=NULL, sigma.split=NULL,\n\t\t\t\t\t\t\tchain.length=500, start.point=NULL,\n\t\t\t\t\t\t\tburn.in=100, num.chains=3, num.jacobians=100 ){\n\n\tpossible.num.knots <- seq( min(num.knots), max(num.knots) )\n\t\n\tif(is.null(start.point)){\n\t\tk <- floor(median(possible.num.knots))\n\t\tknots <- quantile( x, seq(0,1, length=k+2) )\n\t\tnames(knots) <- NULL\n\t\tknots <- knots[-c(1,length(knots))]\n\t\ttemp <- calc.start.point(x, y, degree, knots)\n\t\tstart.point <- NULL\n\t\tfor(i in 1:num.chains){\n\t\t\tstart.point[[i]] <- temp                                    \n\t\t}\t\t\n\t}\n\tif( is.null(sigma.jitter) ){\n\t\tx.range <- range(x)\n\t\tsigma.jitter <- (x.range[2] - x.range[1]) / 10\n\t}\n\tif( is.null(sigma.split) ){\n\t\tx.range <- range(x)\n\t\tsigma.split <- (x.range[2] - x.range[1]) / 5\n\t}\n\t\n\tout <- NULL\n\tout$x <- x\n\tout$y <- y\n\tout$degree <- degree\n\tout$num.knots <- possible.num.knots\n\tout$sigma.jitter <- sigma.jitter\n\tout$sigma.split  <- sigma.split\n\tout$num.chains <- num.chains\n\tout$burn.in <- 0\n\tout$num.jacobians <- num.jacobians\n\n\tout$chains <- NULL\n  out$chain.num.knots <- NULL\n\t# Initial chains\n\tfor(i in 1:num.chains){\n\t\tout$chains[[i]] <- calculate.MCMC.chain( x=x, y=y, \n\t\t\t\t\tpossible.num.knots=possible.num.knots, \n          sigma.jitter=sigma.jitter, sigma.split=sigma.split, \n\t\t\t\t\tn.iter = burn.in + chain.length, \n\t\t\t\t\tstart.point=start.point[[i]], num.jacobians=num.jacobians )\n    out$chain.num.knots[[i]] <- sapply( out$chains[[1]], function(x){length(x$knots)})\n\t}\n\tclass(out) <- 'fiducialSpline'\n\treturn(out)\n}\n\n\n#' Plot the fiducial spline\n#' @param obj A fiducialSpline object created using fiducialSpline \n#' @param grid.length The number of points along the x-axis to predict at. \n#' @param xlab The label of the x-axis\n#' @export\nplot.fiducialSpline <- function(obj, grid.length=401, xlab=''){\n\tx.grid <- seq(min(obj$x), max(obj$x), length=grid.length)\n\tn <- length(obj$chains[[1]])\n\tn.chains <- length(obj$chains)\n\told.mfrow <- par()$mfrow \n\tpar(mfrow=c(n.chains, 1))\n\tfor(i in 1:n.chains){\n\t\tplot(obj$x, obj$y, xlab=xlab)\n\t\tfor(j in 2:n){\n\t\t  lines(x.grid, E.spline(x.grid, obj$chains[[i]][[j]]), col=1)\n\t\t}\n    points(obj$x, obj$y, col='red')    \n\t}\n\tpar(mfrow=old.mfrow)\t\t\n}\n\n#' Calculate the fiducial confidence intervals (credible intervals???)\n#' @param obj A fiducialSpline object created using fiducialSpline \n#' @param level The level of the interval\n#' @export\nconfint.fiducialSpline <- function(obj, level=0.95){\n\tprobs <- c( (1-level)/2, 1-(1-level)/2 )\n\tout <- list()\n  n <- length(obj$chains[[1]])\n  num.knots <- obj$num.knots\n\tfor( i in 1:length(num.knots) ){\n    temp <- NULL\n    # splice the chains together\n    for( j in 1:length(obj$chains) ){\n      temp <- c(temp, obj$chains[[j]][which( sapply(obj$chains[[j]], function(x){length(x$knots)}) == num.knots[i] ) ] ) \n    }\n    # remove the z element and convert from list of lists to a matrix\n    temp <- t(as.matrix( sapply(temp, function(x){out <- x; out$z <- NULL; return(unlist(out))}) ))  \n    \n    if( dim(temp)[1] > 50 ){\n\t\t\tout[[i]] <- t(apply(temp, 2, quantile, probs=probs))\n\t\t}else{\n\t\t\tout[[i]] <- NA\n\t\t}\n\t}\n  if( length(num.knots) == 1 ){\n    out <- out[[1]]\n  }\n\treturn(out)\n}\n\n\n#' Calculate the MCMC acceptance rate\n#' @param obj A fiducialSpline object created using fiducialSpline \n#' @export\nacceptance.rate <- function(obj){\n  n <- length(obj$chains[[1]])\n  num.chains <- obj$num.chains\n  count <- 0\n  for( i in 1:num.chains ){\n    for( j in 2:n ){\n      if( !identical( obj$chains[[i]][[j]], obj$chains[[i]][[j-1]] ) ){\n        count <- count + 1\n      }\n    }\n  }\n  return( count / (num.chains * n) )  \n}\n\n#' Trim the beginning of the MCMC chains\n#' @param obj A fiducialSpline object created using fiducialSpline \n#' @param amount Number of initial steps to remove\n#' @export\ntrim <- function(obj, amount){\n  out <- obj\n  n <- length(out$chains[[1]])\n  if( n > amount){\n    for( i in 1:length(out$chains) ){\n      out$chains[[i]] <- out$chains[[i]][-c(1:amount)]\n    }\n  }else{\n    error('Amount to trim is more than the length of the chain')\n  }\n  return(out)\n}\n\n#' Thin the MCMC chains\n#' @param obj A fiducialSpline object created using fiducialSpline \n#' @param by The thinning interval\n#' @export\nthin <- function(obj, by=10){\n  out <- obj\n  n <- length(out$chains[[1]])\n  for( i in 1:length(out$chains) ){\n    out$chains[[i]] <- out$chains[[i]][ seq(1,n,by=by) ]\n  }\n  return(out)\n}\n\n#' Convert a fiducialSpline object to a mcmc.list\n#' @param obj A fiducialSpline object created using fiducialSpline \n#' @export\nas.mcmc.fiducialSpline <- function(obj){\n  if( length(obj$num.knots) > 1){\n    return( as.mcmc.fiducialSpline.modelSelection(obj) )\n  }else{\n    return( as.mcmc.fiducialSpline.knownNumberKnots(obj) )\n  }\n}\n\n#' Convert a fiducialSpline object to a mcmc.list\n#' @param obj A fiducialSpline object created using fiducialSpline \n#' @export\nas.mcmc.fiducialSpline.modelSelection <- function(obj){\n  out <- list()\n  n <- length(obj$chains[[1]])\n  num.knots <- obj$num.knots\n  \n  out <- list()\n  for( i in 1:length(num.knots) ){\n    temp1 <- NULL\n    for( j in 1:length(obj$chains) ){\n      temp2 <- obj$chains[[j]][which( sapply(obj$chains[[j]], \n                                            function(x){length(x$knots)}) == num.knots[i] ) ]  \n      if( length(temp2) > 0 ){\n        # remove the z element and convert from list of lists to a matrix\n        temp2 <- t(as.matrix( sapply(temp2, function(x){out <- x; out$z <- NULL; return(unlist(out))}) ))  \n        temp1 <- rbind(temp1, temp2)\n      }\n    }\n    if( !is.null(temp1) ){\n      out[[i]] <- as.mcmc(temp1)\n    }else{\n      out[[i]] <- NULL\n    }\n  }\n  \n  if(length(out) == 1){\n    out <- out[[1]]\n  }\n  return(out)\n}\n\n#' Convert a fiducialSpline object to a mcmc.list\n#' @param obj A fiducialSpline object created using fiducialSpline \n#' @export\nas.mcmc.fiducialSpline.knownNumberKnots <- function(obj){\n  out <- list()\n  n <- length(obj$chains[[1]])\n  num.knots <- obj$num.knots\n  for( i in 1:length(num.knots) ){\n    out[[i]] <- list()\n    # splice the chains together\n    for( j in 1:length(obj$chains) ){\n      # remove the z element and convert from list of lists to a matrix\n      temp <- t(as.matrix( sapply(obj$chains[[j]], function(x){out <- x; out$z <- NULL; return(unlist(out))}) ))  \n      out[[i]][[j]] <- as.mcmc(temp)\n    }\n    out[[i]] <- as.mcmc.list(out[[i]])\n  }\n  if(length(out) == 1){\n    out <- out[[1]]\n  }\n  return(out)\n}\n\n\n\n#' Calculate a reasonable starting point for the fiducial MCMC free-knot b-spline\n#' @param x A vector of x-values\n#' @param y A vector of y-values\n#' @param degree The degree of b-spline\n#' @param knots A vector of initial knot points\n#' @export\ncalc.start.point <- function(x, y, degree, knots){\n  temp <- NULL\n  temp$knots <- knots\n  \n  X <- tp(x, knots=temp$knots, degree=degree)\n  XtXinv <- chol2inv(chol(crossprod(X))) \n  beta.hat <- XtXinv %*% crossprod(X, y)\n  sqrtXtXinv <- sqrt.matrix(XtXinv)\n  df <- length(x) - length(knots) - length(beta.hat)\n  e <- X %*% beta.hat - y\n  s2 <- sum(e^2)/df\n  temp$var <- s2\n  temp$z <- rnorm(length(beta.hat))\n  temp$alpha <- as.vector(beta.hat + sqrtXtXinv %*% temp$z)\n  \n  return(temp)\n}\t\n",
    "created" : 1442896101684.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1526937185",
    "id" : "F71EA86B",
    "lastKnownWriteTime" : 1442897968,
    "path" : "~/GitHub/fiducialSplines/R/FiducialSpline.R",
    "project_path" : "R/FiducialSpline.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}